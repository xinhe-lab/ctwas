#' @title Runs cTWAS fine-mapping for regions
#'
#' @param region_data region_data to be finemapped
#'
#' @param LD_map a data frame with filenames of LD matrices for the regions.
#'
#' @param weights a list of preprocessed weights.
#'
#' @param L the number of effects or a vector of number of effects for each region.
#'
#' @param group_prior a vector of two prior inclusion probabilities for SNPs and genes.
#' If NULL, it will use uniform prior inclusion probabilities.
#'
#' @param group_prior_var a vector of two prior variances for SNPs and gene effects.
#' If NULL, it will set prior variance = 50 as the default in \code{susie_rss}.
#'
#' @param null_method Method to compute null model, options: "ctwas", "susie" or "none".
#'
#' @param null_weight Prior probability of no effect (a number between
#'   0 and 1, and cannot be exactly 1). Only used when \code{null_method = "susie"}.
#'
#' @param coverage A number between 0 and 1 specifying the \dQuote{coverage} of the estimated confidence sets
#'
#' @param min_abs_corr Minimum absolute correlation allowed in a credible set.
#'
#' @param include_cs If TRUE, add credible sets (CS) to finemapping results.
#'
#' @param get_susie_alpha If TRUE, get susie alpha matrix from finemapping results.
#'
#' @param snps_only If TRUE, use only SNPs in the region data.
#'
#' @param force_compute_cor If TRUE, force computing correlation (R) matrices
#'
#' @param save_cor If TRUE, save correlation (R) matrices to \code{cor_dir}
#'
#' @param cor_dir a string, the directory to store correlation (R) matrices
#'
#' @param LD_format file format for LD matrix. If "custom", use a user defined
#' \code{LD_loader_fun()} function to load LD matrix.
#'
#' @param LD_loader_fun a user defined function to load LD matrix when \code{LD_format = "custom"}.
#'
#' @param snpinfo_loader_fun a user defined function to load SNP information file,
#' if SNP information files are not in standard cTWAS reference format.
#'
#' @param ncore The number of cores used to parallelize computation over regions
#'
#' @param verbose If TRUE, print detail messages
#'
#' @param logfile the log file, if NULL will print log info on screen
#'
#' @param ... Additional arguments of \code{susie_rss}.
#'
#' @return a list with cTWAS finemapping results.
#'
#' @importFrom logging addHandler loginfo logwarn writeToFile
#' @importFrom parallel mclapply
#'
#' @export
#'
finemap_regions <- function(region_data,
                            LD_map,
                            weights,
                            L = 5,
                            group_prior = NULL,
                            group_prior_var = NULL,
                            min_var = 2,
                            min_gene = 1,
                            null_method = c("ctwas", "susie", "none"),
                            null_weight = NULL,
                            coverage = 0.95,
                            min_abs_corr = 0.1,
                            include_cs = TRUE,
                            get_susie_alpha = TRUE,
                            snps_only = FALSE,
                            force_compute_cor = FALSE,
                            save_cor = FALSE,
                            cor_dir = NULL,
                            LD_format = c("rds", "rdata", "mtx", "csv", "txt", "custom"),
                            LD_loader_fun = NULL,
                            snpinfo_loader_fun = NULL,
                            ncore = 1,
                            verbose = FALSE,
                            logfile = NULL,
                            ...){

  if (!is.null(logfile)){
    addHandler(writeToFile, file=logfile, level='DEBUG')
  }

  loginfo("Fine-mapping %d regions ...", length(region_data))

  # check inputs
  LD_format <- match.arg(LD_format)
  null_method <- match.arg(null_method)

  if (!inherits(region_data,"list"))
    stop("'region_data' should be a list.")

  if (anyDuplicated(names(region_data)))
    logwarn("Duplicated names of region_data found! Please use unique names for region_data!")

  if (missing(LD_map))
    stop("'LD_map' is required when running with LD!")

  if (!inherits(LD_map,"data.frame"))
    stop("'LD_map' should be a data frame!")

  if (missing(weights))
    stop("'weights' is required when running with LD!")

  if (!inherits(weights,"list"))
    stop("'weights' should be a list!")

  if (any(sapply(weights, is.null)))
    stop("'weights' contain NULL, remove empty weights!")

  if (length(L) == 1) {
    L <- rep(L, length(region_data))
    names(L) <- names(region_data)
  } else if (length(L) == length(region_data)) {
    if (!all.equal(names(L), names(region_data)))
      stop("The names of L do not match with region_data!")
  } else {
    stop("L needs to an integer or a vector of the same length as region_data!")
  }

  if (any(L < 1)) {
    loginfo("L needs to be >= 1, set to 1 for %d regions", length(which(L < 1)))
    L[L < 1] <- 1
  }

  # check if all groups have group_prior and group_prior_var
  groups <- unique(unlist(lapply(region_data, "[[", "groups")))
  if (!is.null(group_prior)) {
    groups_without_prior <- setdiff(groups, names(group_prior))
    if (length(groups_without_prior) > 0) {
      stop(paste("Missing group_prior for group:", groups_without_prior, "!"))
    }
  }

  if (!is.null(group_prior_var)) {
    groups_without_prior_var <- setdiff(groups, names(group_prior))
    if (length(groups_without_prior_var) > 0) {
      stop(paste("Missing group_prior_var for group:", groups_without_prior_var, "!"))
    }
  }

  # skip regions with fewer than min_var variables
  if (min_var > 0) {
    region_ids <- names(region_data)
    n_gids <- sapply(region_data, function(x){length(x$gid)})
    n_sids <- sapply(region_data, function(x){length(x$sid)})

    skip_region_ids <- region_ids[(n_sids + n_gids) < min_var]
    if (length(skip_region_ids) > 0){
      loginfo("Skip %d regions with number of variables < %d", length(skip_region_ids), min_var)
      region_data[skip_region_ids] <- NULL
    }

    # skip regions with fewer than min_gene genes
    if (min_gene > 0) {
      skip_region_ids <- region_ids[n_gids < min_gene]
      if (length(skip_region_ids) > 0){
        loginfo("Skip %d regions with number of genes < %d", length(skip_region_ids), min_gene)
        region_data[skip_region_ids] <- NULL
      }
    }
  }

  if (length(region_data) == 0){
    stop("No region data for Fine-mapping.")
  }

  if (verbose) {
    if (is.null(group_prior)) {
      loginfo("Use uniform prior")
    }
    loginfo("null weight method = %s", null_method)
    loginfo("coverage = %s", coverage)
    loginfo("min_abs_corr = %s", min_abs_corr)
  }

  region_ids <- names(region_data)
  res <- mclapply_check(region_ids, function(region_id){
    finemap_single_region(region_data = region_data,
                          region_id = region_id,
                          LD_map = LD_map,
                          weights = weights,
                          L = L[region_id],
                          group_prior = group_prior,
                          group_prior_var = group_prior_var,
                          null_method = null_method,
                          null_weight = null_weight,
                          coverage = coverage,
                          min_abs_corr = min_abs_corr,
                          include_cs = include_cs,
                          get_susie_alpha = get_susie_alpha,
                          snps_only = snps_only,
                          force_compute_cor = force_compute_cor,
                          save_cor = save_cor,
                          cor_dir = cor_dir,
                          LD_format = LD_format,
                          LD_loader_fun = LD_loader_fun,
                          snpinfo_loader_fun = snpinfo_loader_fun,
                          verbose = verbose,
                          ...)
  }, mc.cores = ncore, stop_if_missing = TRUE)

  finemap_res <- do.call(rbind, lapply(res, "[[", 1))
  rownames(finemap_res) <- NULL

  if (get_susie_alpha) {
    susie_alpha_res <- do.call(rbind, lapply(res, "[[", 2))
    rownames(susie_alpha_res) <- NULL
  } else {
    susie_alpha_res <- NULL
  }

  return(list("finemap_res" = finemap_res,
              "susie_alpha_res" = susie_alpha_res))
}

#' @title Runs cTWAS fine-mapping for regions without LD (L = 1)
#'
#' @param region_data region_data to be finemapped
#'
#' @param group_prior a vector of two prior inclusion probabilities for SNPs and genes.
#' If NULL, it will use uniform prior inclusion probabilities.
#'
#' @param group_prior_var a vector of two prior variances for SNPs and gene effects.
#' If NULL, it will set prior variance = 50 as the default in \code{susie_rss}.
#'
#' @param null_method Method to compute null model, options: "ctwas", "susie" or "none".
#'
#' @param null_weight Prior probability of no effect (a number between
#'   0 and 1, and cannot be exactly 1). Only used when \code{null_method = "susie"}.
#'
#' @param get_susie_alpha If TRUE, get susie alpha matrix from finemapping results.
#'
#' @param snps_only If TRUE, use only SNPs in the region data.
#'
#' @param ncore The number of cores used to parallelize computation over regions
#'
#' @param verbose If TRUE, print detail messages
#'
#' @param logfile the log file, if NULL will print log info on screen
#'
#' @param ... Additional arguments of \code{susie_rss}.
#'
#' @return a list with cTWAS finemapping results.
#'
#' @importFrom logging addHandler loginfo logwarn writeToFile
#' @importFrom parallel mclapply
#'
#' @export
#'
finemap_regions_noLD <- function(region_data,
                                 group_prior = NULL,
                                 group_prior_var = NULL,
                                 min_var = 2,
                                 min_gene = 1,
                                 null_method = c("ctwas", "susie", "none"),
                                 null_weight = NULL,
                                 get_susie_alpha = TRUE,
                                 snps_only = FALSE,
                                 ncore = 1,
                                 verbose = FALSE,
                                 logfile = NULL,
                                 ...){

  if (!is.null(logfile)){
    addHandler(writeToFile, file=logfile, level='DEBUG')
  }

  loginfo("Fine-mapping %d regions without LD ...", length(region_data))

  # check inputs
  null_method <- match.arg(null_method)

  if (!inherits(region_data,"list"))
    stop("'region_data' should be a list!")

  if (anyDuplicated(names(region_data)))
    logwarn("Duplicated names of region_data found! Please use unique names for region_data!")

  # check if all groups have group_prior and group_prior_var
  groups <- unique(unlist(lapply(region_data, "[[", "groups")))
  if (!is.null(group_prior)) {
    groups_without_prior <- setdiff(groups, names(group_prior))
    if (length(groups_without_prior) > 0) {
      stop(paste("Missing group_prior for group:", groups_without_prior, "!"))
    }
  }

  if (!is.null(group_prior_var)) {
    groups_without_prior_var <- setdiff(groups, names(group_prior))
    if (length(groups_without_prior_var) > 0) {
      stop(paste("Missing group_prior_var for group:", groups_without_prior_var, "!"))
    }
  }

  # skip regions with fewer than min_var variables
  if (min_var > 0) {
    region_ids <- names(region_data)
    n_gids <- sapply(region_data, function(x){length(x$gid)})
    n_sids <- sapply(region_data, function(x){length(x$sid)})

    skip_region_ids <- region_ids[(n_sids + n_gids) < min_var]
    if (length(skip_region_ids) > 0){
      loginfo("Skip %d regions with number of variables < %d", length(skip_region_ids), min_var)
      region_data[skip_region_ids] <- NULL
    }

    # skip regions with fewer than min_gene genes
    if (min_gene > 0) {
      skip_region_ids <- region_ids[n_gids < min_gene]
      if (length(skip_region_ids) > 0){
        loginfo("Skip %d regions with number of genes < %d", length(skip_region_ids), min_gene)
        region_data[skip_region_ids] <- NULL
      }
    }
  }

  if (length(region_data) == 0){
    stop("No region data for Fine-mapping.")
  }

  if (verbose) {
    if (is.null(group_prior)) {
      loginfo("Use uniform prior")
    }
    loginfo("null weight method = %s", null_method)
  }

  region_ids <- names(region_data)
  res <- mclapply_check(region_ids, function(region_id){
    finemap_single_region_noLD(region_data = region_data,
                               region_id = region_id,
                               group_prior = group_prior,
                               group_prior_var = group_prior_var,
                               null_method = null_method,
                               null_weight = null_weight,
                               get_susie_alpha = get_susie_alpha,
                               snps_only = snps_only,
                               verbose = verbose,
                               ...)
  }, mc.cores = ncore, stop_if_missing = TRUE)

  finemap_res <- do.call(rbind, lapply(res, "[[", 1))
  rownames(finemap_res) <- NULL

  if (get_susie_alpha) {
    susie_alpha_res <- do.call(rbind, lapply(res, "[[", 2))
    rownames(susie_alpha_res) <- NULL
  } else {
    susie_alpha_res <- NULL
  }

  return(list("finemap_res" = finemap_res,
              "susie_alpha_res" = susie_alpha_res))
}

#' @title Finemap regions with cTWAS SER model
#'
#' @param region_data a list object with the susie input data for each region.
#'
#' @param group_prior a vector of prior inclusion probabilities for SNPs and genes.
#'
#' @param group_prior_var a vector of prior variances for SNPs and gene effects.
#'
#' @param min_var minimum number of variables (SNPs and genes) in a region.
#'
#' @param min_gene minimum number of genes in a region.
#'
#' @param null_method Method to compute null model, options: "ctwas", "susie" or "none".
#'
#' @param null_weight Prior probability of no effect (a number between
#'   0 and 1, and cannot be exactly 1). Only used when \code{null_method = "susie"}.
#'
#' @param snps_only If TRUE, use only SNPs in the region data.
#'
#' @param ncore The number of cores used to parallelize computation over regions
#'
#' @param verbose If TRUE, print detail messages
#'
#' @param logfile the log file, if NULL will print log info on screen
#'
#' @return a data frame of SER result for finemapped regions
#'
#' @importFrom logging addHandler loginfo logwarn writeToFile
#' @importFrom parallel mclapply
#'
#' @export
#'
finemap_regions_ser <- function(region_data,
                                group_prior = NULL,
                                group_prior_var = NULL,
                                min_var = 2,
                                min_gene = 1,
                                null_method = c("ctwas", "susie", "none"),
                                null_weight = NULL,
                                snps_only = FALSE,
                                ncore = 1,
                                verbose = FALSE,
                                logfile = NULL){

  if (!is.null(logfile)){
    addHandler(writeToFile, file=logfile, level='DEBUG')
  }

  loginfo("Fine-mapping %d regions with SER model ...", length(region_data))

  # check inputs
  null_method <- match.arg(null_method)

  if (!inherits(region_data,"list"))
    stop("'region_data' should be a list!")

  if (anyDuplicated(names(region_data)))
    logwarn("Duplicated names of region_data found! Please use unique names for region_data!")

  # check if all groups have group_prior and group_prior_var
  groups <- unique(unlist(lapply(region_data, "[[", "groups")))
  if (!is.null(group_prior)) {
    groups_without_prior <- setdiff(groups, names(group_prior))
    if (length(groups_without_prior) > 0) {
      stop(paste("Missing group_prior for group:", groups_without_prior, "!"))
    }
  }

  if (!is.null(group_prior_var)) {
    groups_without_prior_var <- setdiff(groups, names(group_prior))
    if (length(groups_without_prior_var) > 0) {
      stop(paste("Missing group_prior_var for group:", groups_without_prior_var, "!"))
    }
  }

  # skip regions with fewer than min_var variables
  if (min_var > 0) {
    region_ids <- names(region_data)
    n_gids <- sapply(region_data, function(x){length(x$gid)})
    n_sids <- sapply(region_data, function(x){length(x$sid)})

    skip_region_ids <- region_ids[(n_sids + n_gids) < min_var]
    if (length(skip_region_ids) > 0){
      loginfo("Skip %d regions with number of variables < %d", length(skip_region_ids), min_var)
      region_data[skip_region_ids] <- NULL
    }

    # skip regions with fewer than min_gene genes
    if (min_gene > 0) {
      skip_region_ids <- region_ids[n_gids < min_gene]
      if (length(skip_region_ids) > 0){
        loginfo("Skip %d regions with number of genes < %d", length(skip_region_ids), min_gene)
        region_data[skip_region_ids] <- NULL
      }
    }
  }

  if (length(region_data) == 0){
    stop("No region data for Fine-mapping.")
  }

  if (verbose) {
    if (is.null(group_prior)) {
      loginfo("Use uniform prior")
    }
    loginfo("Use %s null weight method", null_method)
  }

  region_ids <- names(region_data)
  res <- mclapply_check(region_ids, function(region_id){
    finemap_single_region_ser(region_data = region_data,
                              region_id = region_id,
                              group_prior = group_prior,
                              group_prior_var = group_prior_var,
                              null_method = null_method,
                              null_weight = null_weight,
                              snps_only = snps_only,
                              verbose = verbose)
  }, mc.cores = ncore, stop_if_missing = TRUE)

  finemap_res <- do.call(rbind, res)
  rownames(finemap_res) <- NULL

  return(finemap_res)
}

# Runs cTWAS finemapping for a single region
finemap_single_region <- function(region_data,
                                  region_id,
                                  LD_map,
                                  weights,
                                  L = 5,
                                  group_prior = NULL,
                                  group_prior_var = NULL,
                                  null_method = c("ctwas", "susie", "none"),
                                  null_weight = NULL,
                                  coverage = 0.95,
                                  min_abs_corr = 0.1,
                                  include_cs = TRUE,
                                  get_susie_alpha = TRUE,
                                  snps_only = FALSE,
                                  force_compute_cor = FALSE,
                                  save_cor = FALSE,
                                  cor_dir = NULL,
                                  LD_format = c("rds", "rdata", "mtx", "csv", "txt", "custom"),
                                  LD_loader_fun = NULL,
                                  snpinfo_loader_fun = NULL,
                                  verbose = FALSE,
                                  ...){

  if (verbose){
    loginfo("Fine-mapping region %s", region_id)
  }

  # check inputs
  LD_format <- match.arg(LD_format)
  null_method <- match.arg(null_method)

  if (!inherits(region_data,"list"))
    stop("'region_data' should be a list.")

  if (!inherits(LD_map,"data.frame"))
    stop("'LD_map' should be a data frame")

  if (!inherits(weights,"list"))
    stop("'weights' should be a list.")

  if (any(sapply(weights, is.null)))
    stop("'weights' contain NULL, remove empty weights!")

  if (L < 1)
    stop("L needs to be >= 1")

  # load input data for the region
  regiondata <- extract_region_data(region_data, region_id,
                                    snps_only = snps_only)
  gids <- regiondata[["gid"]]
  sids <- regiondata[["sid"]]
  z <- regiondata[["z"]]
  gs_group <- regiondata[["gs_group"]]
  g_type <- regiondata[["g_type"]]
  g_context <- regiondata[["g_context"]]
  g_group <- regiondata[["g_group"]]
  groups <- regiondata$groups
  rm(regiondata)

  if (verbose){
    loginfo("%d genes, %d SNPs in the region", length(gids), length(sids))
  }

  if (length(z) < 2) {
    stop(paste(length(z), "variables in the region. At least two variables in a region are needed to run susie"))
  }

  if (!is.null(group_prior)) {
    groups_without_prior <- setdiff(groups, names(group_prior))
    if (length(groups_without_prior) > 0) {
      stop(paste("Missing group_prior for group:", groups_without_prior, "!"))
    }
  }
  if (!is.null(group_prior_var)) {
    groups_without_prior_var <- setdiff(groups, names(group_prior))
    if (length(groups_without_prior_var) > 0) {
      stop(paste("Missing group_prior_var for group:", groups_without_prior_var, "!"))
    }
  }

  res <- initialize_group_priors(group_prior[groups], group_prior_var[groups], groups)
  pi_prior <- res$pi_prior
  V_prior <- res$V_prior
  rm(res)

  # set prior and prior variance values for the region
  res <- set_region_susie_priors(pi_prior, V_prior, gs_group, L = L,
                                 null_method = null_method, null_weight = null_weight)
  prior <- res$prior
  V <- res$V
  null_weight <- res$null_weight
  rm(res)

  cor_res <- get_region_cor(region_id,
                            sids = sids,
                            gids = gids,
                            LD_map = LD_map,
                            weights = weights,
                            force_compute_cor = force_compute_cor,
                            save_cor = save_cor,
                            cor_dir = cor_dir,
                            LD_format = LD_format,
                            LD_loader_fun = LD_loader_fun,
                            snpinfo_loader_fun = snpinfo_loader_fun,
                            verbose = verbose)

  # gene first then SNPs
  R <- rbind(cbind(cor_res$R_gene, t(cor_res$R_snp_gene)),
             cbind(cor_res$R_snp_gene, cor_res$R_snp))
  rm(cor_res)

  if (anyNA(R))
    stop("R matrix contains missing values!")

  if (length(z) != nrow(R))
    stop("R matrix dimension does not match with z!")

  # run susie for this region
  # in susie, prior_variance is under standardized scale (if performed)
  if (verbose){
    loginfo("run susie for region %s with L = %d", region_id, L)
  }
  susie_res <- ctwas_susie_rss(z = z,
                               R = R,
                               prior_weights = prior,
                               prior_variance = V,
                               L = L,
                               null_weight = null_weight,
                               coverage = coverage,
                               min_abs_corr = min_abs_corr,
                               ...)

  susie_res_df <- anno_susie(susie_res,
                             gids = gids,
                             sids = sids,
                             g_type = g_type,
                             g_context = g_context,
                             g_group = g_group,
                             region_id = region_id,
                             z = z,
                             include_cs = include_cs)

  if (get_susie_alpha) {
    # extract alpha matrix from susie result
    susie_alpha_df <- get_susie_alpha_res(susie_res, susie_res_df, keep_genes_only = TRUE)
  } else {
    susie_alpha_df <- NULL
  }

  return(list("susie_res_df" = susie_res_df,
              "susie_alpha_df" = susie_alpha_df))

}


# Runs cTWAS finemapping for a single region without LD
finemap_single_region_noLD <- function(region_data,
                                       region_id,
                                       group_prior = NULL,
                                       group_prior_var = NULL,
                                       null_method = c("ctwas", "susie", "none"),
                                       null_weight = NULL,
                                       coverage = 0.95,
                                       include_cs = TRUE,
                                       get_susie_alpha = TRUE,
                                       snps_only = FALSE,
                                       verbose = FALSE,
                                       ...){

  if (verbose){
    loginfo("Fine-mapping region %s without LD", region_id)
  }

  # check inputs
  null_method <- match.arg(null_method)

  if (!inherits(region_data,"list"))
    stop("'region_data' should be a list.")

  regiondata <- extract_region_data(region_data, region_id,
                                    snps_only = snps_only)
  gids <- regiondata[["gid"]]
  sids <- regiondata[["sid"]]
  z <- regiondata[["z"]]
  gs_group <- regiondata[["gs_group"]]
  g_type <- regiondata[["g_type"]]
  g_context <- regiondata[["g_context"]]
  g_group <- regiondata[["g_group"]]
  groups <- regiondata$groups
  rm(regiondata)

  if (verbose){
    loginfo("%d genes, %d SNPs in the region", length(gids), length(sids))
  }

  if (length(z) < 2) {
    stop(paste(length(z), "variables in the region. At least two variables in a region are needed to run susie"))
  }

  if (!is.null(group_prior)) {
    groups_without_prior <- setdiff(groups, names(group_prior))
    if (length(groups_without_prior) > 0) {
      stop(paste("Missing group_prior for group:", groups_without_prior, "!"))
    }
  }
  if (!is.null(group_prior_var)) {
    groups_without_prior_var <- setdiff(groups, names(group_prior))
    if (length(groups_without_prior_var) > 0) {
      stop(paste("Missing group_prior_var for group:", groups_without_prior_var, "!"))
    }
  }

  res <- initialize_group_priors(group_prior[groups], group_prior_var[groups], groups)
  pi_prior <- res$pi_prior
  V_prior <- res$V_prior
  rm(res)

  # set prior and prior variance values for the region
  res <- set_region_susie_priors(pi_prior, V_prior, gs_group, L = 1,
                                 null_method = null_method, null_weight = null_weight)
  prior <- res$prior
  V <- res$V
  null_weight <- res$null_weight
  rm(res)

  # use an identity matrix as R in no-LD version
  R <- diag(length(z))

  if (anyNA(R))
    stop("R matrix contains missing values!")

  if (length(z) != nrow(R))
    stop("R matrix dimension does not match with z!")

  # run susie for this region
  # in susie, prior_variance is under standardized scale (if performed)
  if (verbose){
    loginfo("run susie for region %s with L = 1", region_id)
  }
  susie_res <- ctwas_susie_rss(z = z,
                               R = R,
                               prior_weights = prior,
                               prior_variance = V,
                               L = 1,
                               null_weight = null_weight,
                               coverage = coverage,
                               min_abs_corr = 0,
                               ...)

  susie_res_df <- anno_susie(susie_res,
                             gids = gids,
                             sids = sids,
                             g_type = g_type,
                             g_context = g_context,
                             g_group = g_group,
                             region_id = region_id,
                             z = z,
                             include_cs = include_cs)

  if (get_susie_alpha) {
    # extract alpha matrix from susie result
    susie_alpha_df <- get_susie_alpha_res(susie_res, susie_res_df, keep_genes_only = TRUE)
  } else {
    susie_alpha_df <- NULL
  }

  return(list("susie_res_df" = susie_res_df,
              "susie_alpha_df" = susie_alpha_df))
}

# Runs cTWAS finemapping for a single region using cTWAS SER model
finemap_single_region_ser <- function(region_data,
                                      region_id,
                                      group_prior = NULL,
                                      group_prior_var = NULL,
                                      null_method = c("ctwas", "susie", "none"),
                                      null_weight = NULL,
                                      snps_only = FALSE,
                                      verbose = FALSE){

  if (verbose){
    loginfo("Fine-mapping region %s with SER model", region_id)
  }

  # check inputs
  null_method <- match.arg(null_method)

  if (!inherits(region_data,"list"))
    stop("'region_data' should be a list.")

  regiondata <- extract_region_data(region_data, region_id,
                                    snps_only = snps_only)
  gids <- regiondata[["gid"]]
  sids <- regiondata[["sid"]]
  z <- regiondata[["z"]]
  gs_group <- regiondata[["gs_group"]]
  g_type <- regiondata[["g_type"]]
  g_context <- regiondata[["g_context"]]
  g_group <- regiondata[["g_group"]]
  groups <- regiondata$groups
  rm(regiondata)

  if (verbose){
    loginfo("%d genes, %d SNPs in the region", length(gids), length(sids))
  }

  if (length(z) < 2) {
    stop(paste(length(z), "variables in the region. At least two variables in a region are needed to run susie"))
  }

  if (!is.null(group_prior)) {
    groups_without_prior <- setdiff(groups, names(group_prior))
    if (length(groups_without_prior) > 0) {
      stop(paste("Missing group_prior for group:", groups_without_prior, "!"))
    }
  }
  if (!is.null(group_prior_var)) {
    groups_without_prior_var <- setdiff(groups, names(group_prior))
    if (length(groups_without_prior_var) > 0) {
      stop(paste("Missing group_prior_var for group:", groups_without_prior_var, "!"))
    }
  }

  res <- initialize_group_priors(group_prior[groups], group_prior_var[groups], groups)
  pi_prior <- res$pi_prior
  V_prior <- res$V_prior
  rm(res)

  # set priors, prior variances
  res <- set_region_susie_priors(pi_prior, V_prior, gs_group, L = 1,
                                 null_method = "none")
  prior_weights <- res$prior
  prior_variance <- res$V
  rm(res)

  # fit SER model
  ser_res <- ctwas_ser_rss(z = z,
                           prior_weights = prior_weights,
                           prior_variance = prior_variance,
                           null_method = null_method,
                           null_weight = null_weight)

  # annotate SER result
  ser_res_df <- anno_ser_res(ser_res,
                             gids,
                             sids,
                             g_type = g_type,
                             g_context = g_context,
                             g_group = g_group,
                             region_id = region_id,
                             z = z)

  return(ser_res_df)

}

# finemap a single region with cTWAS SER model, used in EM
# this replaces the earlier function `fast_finemap_single_region_L1_noLD()`
fast_finemap_single_region_ser_rss <- function(region_data,
                                               region_id,
                                               pi_prior,
                                               V_prior,
                                               null_method = c("ctwas", "susie", "none"),
                                               null_weight = NULL,
                                               return_full_result = FALSE){


  null_method <- match.arg(null_method)

  # load region data
  if (!inherits(region_data,"list")){
    stop("'region_data' should be a list.")
  }

  regiondata <- region_data[[region_id]]
  if (is.null(regiondata$z) || is.null(regiondata$gs_group)){
    regiondata <- extract_region_data(region_data, region_id)
  }

  gids <- regiondata[["gid"]]
  sids <- regiondata[["sid"]]
  z <- regiondata[["z"]]
  gs_group <- regiondata[["gs_group"]]
  g_type <- regiondata[["g_type"]]
  g_context <- regiondata[["g_context"]]
  g_group <- regiondata[["g_group"]]
  rm(regiondata)

  if (length(z) < 2) {
    stop(paste(length(z), "variables in the region", region_id, "\n",
               "At least two variables in a region are needed to run SER model"))
  }

  # set priors, prior variances
  res <- set_region_susie_priors(pi_prior, V_prior, gs_group, L = 1,
                                 null_method = "none")
  prior_weights <- res$prior
  prior_variance <- res$V
  rm(res)

  # fit SER model
  ser_res <- ctwas_ser_rss(z = z,
                           prior_weights = prior_weights,
                           prior_variance = prior_variance,
                           null_method = null_method,
                           null_weight = null_weight)

  # annotate SER result
  ser_res_df <- anno_ser_res(ser_res,
                             gids,
                             sids,
                             g_type = g_type,
                             g_context = g_context,
                             g_group = g_group,
                             region_id = region_id,
                             z = z)

  if (return_full_result){
    return(list("ser_res" = ser_res,
                "ser_res_df" = ser_res_df))
  }else{
    return(ser_res_df)
  }

}
