---
title: "Using cTWAS modules"
author: "Kaixuan Luo, Sheng Qian"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using cTWAS modules}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE,
                      warning = FALSE,
                      fig.width = 6,
                      fig.height = 4,
                      fig.align = "center",
                      fig.cap = "&nbsp;",
                      dpi = 120)
```



Running cTWAS involves several major steps: preparing input data, computing Z-scores of molecular traits, estimating parameters, screening for candidate genomic regions, and fine-mapping these regions. In this tutorial, we will show how to perform cTWAS analysis by running each of the cTWAS modules separately. This would allow more flexible controls of the cTWAS modules with different settings (memory, parallelization, etc.). We could save the results from each module for future access.

We require first running the data preprocessing and harmonization steps before running cTWAS main analysis. Please follow the "Preparing cTWAS input data" tutorial.

Note: One can run cTWAS without using reference LD data. See “A minimal tutorial of running cTWAS without LD”. That tutorial describes how to run cTWAS in a single step. 

In this version of cTWAS, we allow the joint analysis of multiple groups of molecular traits. This could be: eQTL of multiple tissues; or eQTLs, splicing QTLs and other types of QTLs in a single tissue. In a more complex setting, multiple types of QTL data from multiple tissues/cell types. Each group is defined by its “type” (kind of molecular traits), and “context” (tissue, cell type, condition, etc.). Please see the section "Harmonizing prediction models and the reference data" in the "Preparing cTWAS input data" tutorial. 

Below, we provide information about how to do cTWAS analysis with LD in several steps. 

Load the packages
```{r load_package, message=FALSE}
library(ctwas)
```


In this tutorial, we use sample data of LDL on chromosome 16. These data are provided in the R package. 

We first load the preprocessed input data: 
```{r load_sample_data}
z_snp <- readRDS(system.file("extdata/sample_data", "LDL_example.preprocessed.z_snp.RDS", package = "ctwas"))


weights <- readRDS(system.file("extdata/sample_data", "LDL_example.preprocessed.weights.RDS", package = "ctwas"))

region_info <- readRDS(system.file("extdata/sample_data", "LDL_example.region_info.RDS", package = "ctwas"))

snp_map <- readRDS(system.file("extdata/sample_data", "LDL_example.snp_map.RDS", package = "ctwas"))

LD_map <- readRDS(system.file("extdata/sample_data", "LDL_example.LD_map.RDS", package = "ctwas"))

z_gene <- readRDS(system.file("extdata/sample_data", "LDL_example.z_gene.RDS", 
package = "ctwas"))
```


+ `z_snp` is a data frame with preprocessed GWAS z-scores, 

+ `weights` is a list of preprocessed weights from prediction models, 

+ `region_info` is a data frame with region definitions, 

+ `snp_map` is a list of data frames with SNP-to-region map for the reference, 

+ `LD_map` is a data frame with paths to the LD matrices,

+ `z_gene` is a data frame with computed Z-scores of molecular traits. 

*Note*: `LD_map` is not needed when running cTWAS without LD. 

## Assemble input data for the regions

Because cTWAS runs region-by-region, we will first need to prepare the data for each region, combining information of all variants and molecular traits in that region. After data preprocessing and computation of Z-scores of molecular traits, we assemble the input data for all the regions using the function `assemble_region_data()`.  It assigns molecular traits, variants and their Z-scores to each region. 
```{r assemble_region_data, eval=FALSE}
res <- assemble_region_data(region_info, 
                            z_snp, 
                            z_gene, 
                            weights, 
                            snp_map,
                            thin = 0.1, 
                            maxSNP = 20000, 
                            ncore = 6)
region_data <- res$region_data
boundary_genes <- res$boundary_genes
```


The function has a few arguments to control its behavior. The `thin` argument randomly selects a subset of variants (10% when thin = 0.1) to use during parameter estimation and screening for candidate regions. This helps reduce computation. If `thin = 1`, it will use all the SNPs. `maxSNP` sets a maximum on the number of variants that can be in a single region to prevent memory issues during fine-mapping. If the number of SNPs in a region is more than `maxSNP`, It will trim the SNPs (randomly, by default) in the region. `ncore` specifies the number of cores to use when parallelizing over regions.

This functions returns `region_data`, a list object containing input data (IDs of molecular traits and variants, their Z-scores, genomic boundaries, etc.) for each of the regions, 
as well as a data frame `boundary_genes`, containing the information of molecular traits that cross region boundaries.


## Estimating parameters

We use the `est_param()` function to estimate two sets of parameters: the prior inclusion probabilities and the prior effect size variance. It will take the assembled `region_data` as input. 

As described in the Introduction, cTWAS can analyze multiple groups of molecular traits. This step will estimate the prior parameters for each group. But we allow sharing of the prior effect variance parameters among groups. This may improve the accuracy of parameter estimation. If the input data has several groups of similar molecular traits (e.g. eQTLs from several brain regions), estimation of parameters for each group separately may lead to relatively large estimation error. There are several options to control how parameters are shared among groups. This can be done by specifying the `group_prior_var_stucture`:

- "shared_type" (default option) allows all groups in one molecular QTL type to share the same variance parameter.
-  "shared_context" allows all groups in one context (tissue, cell type, condition) to share the same variance parameter.
- "shared_nonSNP" allows all non-SNP groups to share the same variance parameter.
- "shared_all" allows all groups to share the same variance parameter.
- "independent" allows all groups to have their own separate variance parameters.

This step will run the EM algorithm to estimate parameters and return the estimated parameters (`group_prior`, `group_prior_var`, etc.). For technical reasons (see Methods of the cTWAS paper), it will run two rounds of EM algorithm. In the first round, it uses fewer iterations (`niter_prefit=3` by default) to get rough parameter estimates, and using these values, select regions for the analysis in the second run of EM. We use more iterations in the second round (`niter=30` by default) to get accurate parameter estimates. 

```{r est_param, eval=FALSE}
param <- est_param(region_data, 
                   group_prior_var_structure = "shared_type", 
                   niter_prefit = 3,
                   niter = 30, 
                   ncore = 6)
group_prior <- param$group_prior
group_prior_var <- param$group_prior_var
```


*Note:*, we used sample data (from chr16) in this example, however, in real data analysis, parameter estimation should be done using data from the *entire genome*.

## Screening regions

After parameter estimation, we use the `screen_regions()` function to perform a screening process to select regions with likely causal signals in molecular traits. To find these regions, we perform an initial fine-mapping with thinned SNPs (a subset of all variants, see the Section “Assemble input data”). Only these regions would be subject to full fine-mapping analysis, using all variants, in the final step. Thus screening regions can save computational time. 

cTWAS have two options to screen regions:
 
+ screening by the number of causal signals: If `filter_L = TRUE`, ctwas will first estimate the number of causal signals (L) for each region. This step is done using uniform prior, treating all variants and molecular traits equally. From the results, we obtain the number of credible sets (L). We then select regions with at least one credible set. Note, this option is not available for the "no-LD" version. 

+ screening by non-SNP PIPs: If `filter_nonSNP_PIP = TRUE`, ctwas will compute the non-SNP PIP for each region (using estimated L and estimated priors). It then selects regions by applying a  `min_nonSNP_PIP` cutoff (0.5, by default). This way, only regions containing potentially causal molecular traits would be chosen for final analysis. 

When running with LD, we recommend screening by the number of causal signals, i.e. setting `filter_L = TRUE` and `filter_nonSNP_PIP = FALSE`. 

```{r screen_regions_cs, eval=FALSE}
res <- screen_regions(region_data,
                      use_LD = TRUE,
                      LD_map = LD_map,
                      snp_map = snp_map, 
                      weights = weights,
                      filter_L = TRUE,
                      filter_nonSNP_PIP = FALSE,
                      ncore = 6)
screened_region_data <- res$screened_region_data
L <- res$L
```


It returns `screened_region_data` which contains a subset of region data for selected regions. It also returns the estimated L (number of credible sets) for the selected regions, which could be used in the fine-mapping step to set L for each region.

When running without LD, ctwas would only perform screening regions by non-SNP PIPs, and  it will automatically set `filter_nonSNP_PIP = TRUE` and `filter_L = FALSE`.

```{r screen_regions_nonSNP_PIP, eval=FALSE}
res <- screen_regions(region_data,
                      use_LD = FALSE,
                      group_prior = group_prior,
                      group_prior_var = group_prior_var,
                      filter_L = FALSE,
                      filter_nonSNP_PIP = TRUE,
                      min_nonSNP_PIP = 0.5,
                      ncore = 6)
screened_region_data <- res$screened_region_data
```


After selecting regions, we expand the screened regions with full sets of SNPs for final fine-mapping. (This is not needed when `thin = 1`.)

```{r expand_region_data, eval=FALSE}
screened_region_data <- expand_region_data(screened_region_data,
                                           snp_map,
                                           z_snp,
                                           z_gene,
                                           maxSNP = 20000,
                                           ncore = ncore)
```


If the number of SNPs in a region is more than `maxSNP`, It will trim the SNPs in the region (according to the Z-scores, by default).

## Fine-mapping screened regions

We now perform the fine-mapping step for each of the screened regions with the estimated parameters.

The `finemap_regions()` function performs fine-mapping for the regions in the `screened_region_data`.

It first computes correlation matrices among all variables included in fine-mapping (SNPs, and molecular traits), then runs fine-mapping with estimated parameters (`group_prior` and `group_prior_var`) and estimated number of causal signals (`L`), and returns a data frame with fine-mapping results for the regions. 
```{r finemap_regions, eval=FALSE}
finemap_res <- finemap_regions(screened_region_data,
                               use_LD = TRUE,
                               LD_map = LD_map,
                               snp_map = snp_map,
                               weights = weights,
                               group_prior = group_prior,
                               group_prior_var = group_prior_var,
                               L = L,
                               save_cor = TRUE,
                               cor_dir = "./cor_matrix",
                               ncore = ncore)
```


We can save the computed correlation matrices to the directory `cor_dir` for future access, by setting `save_cor = TRUE`.

*Note*: it is also possible to run fine-mapping without LD:
```{r finemap_regions_noLD, eval=FALSE}
finemap_res <- finemap_regions(screened_region_data,
                               use_LD = FALSE,
                               group_prior = group_prior,
                               group_prior_var = group_prior_var,
                               ncore = 6)
```



## Fine-mapping a single region

We could also run fine-mapping for a single region (or several regions of interest) with precomputed parameters. This is particularly useful to perform a deep analysis on molecular traits/regions of interest. 

Here we show an example for fine mapping a single region "16_71020125_72901251".

We first expand the region of interest with a full set of SNPs using the assembled `region_data`, and select the number of causal signals (`L`) for this region.

```{r example_region, eval=FALSE}
region_id <-16_71020125_72901251"
selected_region_data <- expand_region_data(region_data[region_id],
                                           snp_map,
                                           z_snp,
                                           z_gene,
                                           maxSNP = 20000)
```


We could then perform fine-mapping for this region of interest:

```{r finemap_single_region, eval=FALSE}
selected_region_L <- L[region_id]
finemap_region_res <- finemap_regions(selected_region_data,
                                      use_LD = TRUE,
                                      LD_map = LD_map,
                                      snp_map = snp_map,
                                      weights = weights,
                                      group_prior = group_prior,
                                      group_prior_var = group_prior_var,
                                      L = selected_region_L,
                                      save_cor = TRUE,
                                      cor_dir = "./cor_matrix")
```


We could also perform fine-mapping without LD:

```{r finemap_single_region_noLD, eval=FALSE}
finemap_region_res <- finemap_regions(selected_region_data,
                                      use_LD = FALSE,
                                      group_prior = group_prior,
                                      group_prior_var = group_prior_var)
```



