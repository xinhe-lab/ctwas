---
title: "Using cTWAS modules"
author: "Kaixuan Luo, Sheng Qian"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using cTWAS modules}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE,
                      warning = FALSE,
                      fig.width = 6,
                      fig.height = 4,
                      fig.align = "center",
                      fig.cap = "&nbsp;",
                      dpi = 120)
```



Running cTWAS involves several major steps: preparing input data, computing z-scores of genes, estimating parameters, screening for candidate genomic regions, and fine-mapping these regions. In this tutorial, we will show how to perform cTWAS analysis by running each of the cTWAS modules separately. This would allow more flexible controls of the cTWAS modules with different settings (memory, parallelization, etc.). We could save the results from each module for future access.

We require first running the data preprocessing and harmonization steps before running cTWAS main analysis. Please follow the "Preparing cTWAS input data" tutorial to prepare cTWAS input data.

*Important*: It is possible to run cTWAS without any reference LD data. This would make the data preparation and analysis considerably simpler and faster. To do this, we make the assumption that there is at most one causal signal (either a variant or a gene) in a single GWAS locus. The downside of running cTWAS without LD is that you may miss secondary signals in certain regions. See the section below “Running cTWAS without LD” for details.  

Load the packages
```{r load_package, message=FALSE}
library(ctwas)
```


In this tutorial, we use sample data of LDL on chromosome 16. These data are provided in the R package. 

We first load the preprocessed input data: 
```{r load_sample_data}
z_snp <- readRDS(system.file("extdata/sample_data", "LDL_example.preprocessed.z_snp.RDS", package = "ctwas"))


weights <- readRDS(system.file("extdata/sample_data", "LDL_example.preprocessed.weights.RDS", package = "ctwas"))

region_info <- readRDS(system.file("extdata/sample_data", "LDL_example.region_info.RDS", package = "ctwas"))

snp_info <- readRDS(system.file("extdata/sample_data", "LDL_example.snp_info.RDS", package = "ctwas"))

LD_info <- readRDS(system.file("extdata/sample_data", "LDL_example.LD_info.RDS", package = "ctwas"))

z_gene <- readRDS(system.file("extdata/sample_data", "LDL_example.z_gene.RDS", 
package = "ctwas"))
```


+ `z_snp` is a data frame with preprocessed GWAS z-scores, 

+ `weights` is a list of preprocessed weights from prediction models, 

+ `region_info` is a data frame with region definitions, 

+ `snp_info` is a list of SNP information in all the regions, 

+ `LD_info` is a data frame with paths to the LD matrices,

+ `z_gene` is a data frame with computed Z-scores of genes. 

Please refer to the "Preparing cTWAS input data" tutorial for more details.

## Assemble input data for the regions

Because cTWAS runs region-by-region, we will first need to prepare data for each region. After data preprocessing and computation of Z-scores of genes, we assemble the input data for all the regions using the function `assemble_region_data()`.  It assigns genes, variants and their Z-scores to each region. 
```{r assemble_region_data, eval=FALSE}
res <- assemble_region_data(region_info, z_snp, z_gene, weights, snp_info,
                            thin = 0.1, maxSNP = 20000, ncore = 6)
region_data <- res$region_data
boundary_genes <- res$boundary_genes
```


The function has a few arguments to control its behavior. The `thin` argument randomly selects a subset of variants (10% when thin = 0.1) to use during parameter estimation and screening for candidate regions. This helps reduce computation. If `thin = 1`, it will use all the SNPs. `maxSNP` sets a maximum on the number of variants that can be in a single region to prevent memory issues during fine-mapping. If the number of SNPs in a region is more than `maxSNP`, It will trim the SNPs (randomly, by default) in the region. `ncore` specifies the number of cores to use when parallelizing over regions.

This functions returns `region_data`, a list object containing input data (IDs of genes and variants, their Z-scores, genomic boundaries, etc.) for each of the regions, 
as well as a data frame `boundary_genes`, containing the information of genes that cross region boundaries.

## Estimating parameters

We use the `est_param()` function to estimate two sets of parameters: the prior inclusion probabilities and the prior effect size variance. It will take the assembled `region_data` as input. 

This step will run the EM algorithm to estimate parameters and return the estimated parameters (`group_prior`, `group_prior_var`, etc.). For technical reasons (see Methods of the cTWAS paper), it will run two rounds of EM algorithm. In the first round, it uses fewer iterations (`niter_prefit=3` by default) to get rough parameter estimates, and using these values, select regions for the analysis in the second run of EM. We use more iterations in the second round (`niter=30` by default) to get accurate parameter estimates. 

```{r est_param, eval=FALSE}
param <- est_param(region_data, 
                   niter_prefit = 3,
                   niter = 30, 
                   ncore = 6)
group_prior <- param$group_prior
group_prior_var <- param$group_prior_var
```


*Note:*, we used sample data (from chr16) in this example, however, in real data analysis, parameter estimation should be done using data from the *entire genome*.

## Screening regions

After parameter estimation, we use the `screen_regions()` function to perform a screening process to select regions with likely causal signals in genes. Only these regions would be subject to full fine-mapping analysis, using all genetic variants, in the final step. Thus screening regions can save computational time. To find these regions, we perform an initial fine-mapping with thinned SNPs (a subset of all variants, see the Section “Assemble input data”).

By default, we first estimate the numbers of causal signals (L) in each region by running regular fine-mapping with uniform prior, and select regions with at least one causal signal (L >= 1):

```{r screen_regions_cs, eval=FALSE}
res <- screen_regions(region_data,
                      use_LD = TRUE,
                      LD_info = LD_info,
                      snp_info = snp_info, 
                      weights = weights, 
                      ncore = 6)
screened_region_data <- res$screened_region_data
L <- res$L
```


It returns `screened_region_data` which contains a subset of region data for selected regions. It also returns the estimated L (number of credible sets) for all the regions. 

*Note*: it is possible to screen regions without LD.  In the "no-LD" version,  we run fine-mapping with `L=1` using estimated priors. Then, it computes the total PIP from genes (non-SNPs) and selects regions non-SNP PIPs with greater than 0.5 (by default). 
```{r screen_regions_nonSNP_PIP, eval=FALSE}
res <- screen_regions(region_data,
                      use_LD = FALSE,
                      group_prior = group_prior,
                      group_prior_var = group_prior_var,
                      min_nonSNP_PIP = 0.5,
                      ncore = 6)
screened_region_data <- res$screened_region_data
nonSNP_PIPs <- res$nonSNP_PIPs
```


It returns `screened_region_data`, as well as the non-SNP PIPs for all the regions. We could check the non-SNP PIPs and adjust the screened regions by choosing different `min_nonSNP_PIP` cutoffs.

After selecting regions, we expand the screened regions with full sets of SNPs for final fine-mapping. 

```{r expand_region_data, eval=FALSE}
screened_region_data <- expand_region_data(screened_region_data,
                                           snp_info,
                                           z_snp,
                                           z_gene,
                                           maxSNP = 20000,
                                           ncore = ncore)
```


If the number of SNPs in a region is more than `maxSNP`, It will trim the SNPs in the region (according to the Z-scores, by default).

This step is not needed when `thin = 1`.

## Fine-mapping screened regions

We now perform the fine-mapping step for each of the screened regions with the estimated parameters.

The `finemap_regions()` function performs fine-mapping for the regions in the `screened_region_data`.

It first computes correlation matrices among all variables included in fine-mapping (SNPs, and genes), then runs fine-mapping with estimated parameters (`group_prior` and `group_prior_var`) and estimated number of causal signals (`L`), and returns a data frame with fine-mapping results for the regions. 
```{r finemap_regions, eval=FALSE}
finemap_res <- finemap_regions(screened_region_data,
                               use_LD = TRUE,
                               LD_info = LD_info,
                               snp_info = snp_info,
                               weights = weights,
                               group_prior = group_prior,
                               group_prior_var = group_prior_var,
                               L = L,
                               save_cor = TRUE,
                               cor_dir = "./cor_matrix",
                               ncore = ncore)
```


We can save the computed correlation matrices to the directory `cor_dir` for future access, by setting `save_cor = TRUE`.

*Note*: it is also possible to run fine-mapping without LD:
```{r finemap_regions_noLD, eval=FALSE}
finemap_res <- finemap_regions(screened_region_data,
                               use_LD = FALSE,
                               group_prior = group_prior,
                               group_prior_var = group_prior_var,
                               ncore = 6)
```



## Fine-mapping a single region

We could also run fine-mapping for a single region (or several regions of interest) with precomputed parameters. 

Here we show an example for fine mapping a single region "16_71020125_72901251".

We first expand the region of interest with a full set of SNPs using the assembled `region_data`, and select the number of causal signals (`L`) for this region.

```{r example_region, eval=FALSE}
region_id <-16_71020125_72901251"
selected_region_data <- expand_region_data(region_data[region_id],
                                           snp_info,
                                           z_snp,
                                           z_gene,
                                           maxSNP = 20000)
selected_region_L <- L[region_id]
```


We could then perform fine-mapping for this region of interest:
```{r finemap_single_region, eval=FALSE}
finemap_region_res <- finemap_regions(selected_region_data,
                                      use_LD = TRUE,
                                      LD_info = LD_info,
                                      snp_info = snp_info,
                                      weights = weights,
                                      group_prior = group_prior,
                                      group_prior_var = group_prior_var,
                                      L = selected_region_L,
                                      save_cor = TRUE,
                                      cor_dir = "./cor_matrix")
```


